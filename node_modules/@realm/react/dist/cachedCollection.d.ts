/// <reference types="react" />
import Realm from "realm";
/**
 * Arguments object for {@link createCachedCollection}.
 */
type CachedCollectionArgs<T> = {
    /**
     * The {@link Realm.Collection} to proxy
     */
    collection: Realm.List<T> | Realm.Results<T>;
    /**
     * The {@link Realm} instance
     */
    realm: Realm;
    /**
     * Callback which is called whenever an object in the collection changes
     */
    updateCallback: () => void;
    /**
     * Reference boolean which is set to true whenever an object in the collection changes
     * It is used to determine if the collection's object reference should be updated
     * The implementing component should reset this to false when updating its object reference
     */
    updatedRef: React.MutableRefObject<boolean>;
    /**
     * Optional Map to be used as the cache. This is used to allow a `sorted` or `filtered`
     * (derived) version of the collection to reuse the same cache, preventing excess new object
     * references being created.
     */
    objectCache?: Map<string, T>;
    /**
     * Optional flag specifying that this is a derived (`sorted` or `filtered`) version of
     * an existing collection, so we should not create or remove listeners or clear the cache
     * when this is torn down.
     */
    isDerived?: boolean;
    /**
     * Optional list of key-paths to limit notifications.
     */
    keyPaths?: string[];
};
/**
 * Creates a proxy around a {@link Realm.Collection} that will create new {@link Realm.Object}
 * references on any relevant change (update, insert, deletion) and return the same
 * object reference if no changes have occurred since the last access.
 *
 * This makes the {@link Realm.Collection} behaves in an immutable way, as React expects, so
 * that a {@link Realm.Object} can be wrapped in {@link React.memo} to prevent unnecessary
 * rendering (see {@link useQuery} hook).
 * @param args {@link CachedCollectionArgs} object arguments
 * @returns Proxy object wrapping the collection
 */
export declare function createCachedCollection<T extends Realm.Object<any>>({ collection, realm, updateCallback, updatedRef, objectCache, isDerived, keyPaths, }: CachedCollectionArgs<T>): {
    collection: Realm.Results<T> | Realm.List<T>;
    tearDown: () => void;
};
export {};
//# sourceMappingURL=cachedCollection.d.ts.map