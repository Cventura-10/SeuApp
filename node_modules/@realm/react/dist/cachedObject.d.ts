/// <reference types="react" />
import Realm from "realm";
/**
 * Arguments object for `cachedObject`.
 */
type CachedObjectArgs = {
    /**
     * The {@link Realm.Object} to proxy
     */
    object: Realm.Object | null;
    /**
     * The {@link Realm} instance
     */
    realm: Realm;
    /**
     * Callback function called whenver the object changes. Used to force a component
     * using the {@link useObject} hook to re-render.
     */
    updateCallback: () => void;
    /**
     * Reference boolean which is set to true whenever the object changes
     * It is used to determine if the object's reference should be updated
     * The implementing component should reset this to false when updating its object reference
     */
    updatedRef: React.MutableRefObject<boolean>;
    /**
     * Optional list of key-paths to limit notifications.
     */
    keyPaths?: string[];
};
export type CachedObject = {
    object: Realm.Object | null;
    tearDown: () => void;
};
/**
 * Creates a proxy around a {@link Realm.Object} that will return a new reference
 * on any relevant update to the object itself. It also wraps accesses to {@link Realm.List}
 * attributes into a {@link cachedCollection}, so that any update, insert or deletion to the
 * list will also return a new object reference.
 *
 * See {@link cachedCollection} and the `useObject` hook for description of how this
 * helps prevent unnecessary rendering.
 * @param args - {@link CachedObjectArgs} object arguments
 * @returns Proxy object wrapping the {@link Realm.Object}
 */
export declare function createCachedObject({ object, realm, updateCallback, updatedRef, keyPaths, }: CachedObjectArgs): CachedObject;
export {};
//# sourceMappingURL=cachedObject.d.ts.map